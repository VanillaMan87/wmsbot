#pragma config(Motor,  port1,           dr,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           stl,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           sbl,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           str,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           sbr,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           intakefront,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intakeback,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           m8,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           m9,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          dl,            tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 ____           ______ _ _             ____
| __ ) _ __ ___|__  (_) | | __ _      |  _ \ _____   __
|  _ \| '__/ _ \ / /| | | |/ _` |_____| |_) / _ \ \ / /
| |_) | | | (_) / /_| | | | (_| |_____|  _ <  __/\ V /
|____/|_|  \___/____|_|_|_|\__,_|     |_| \_\___| \_/


*** This is the same code as BroZilla, but shooter motors are reversed.

Team Error 404
Weston Middle School
*/

task main()	{

	while (true) {

		int shooterButtonToggleState = 0;
		int shooterButtonPressed = 0;


		int shooterSpeed = 127;

		// Used to filter out joystick abberations
		int threshold = 10;

		//////////////////////////////////////////////////////////
		//
		// DRIVE
		//
		// This code has filtering in place
		// Because the joystick returns a value that is not always
		// exactly zero.
		//
		// Because of this, the Cortex makes a whining sound
		// because the drive motors are being triggered
		// with values less than 10
		//
		// By testing if the joystick is within the threshold
		// We can turn off the motors and stop the noise
		// and power drain

		if(abs(vexRT[Ch3]) > threshold)         // If the left joystick is greater than or less than the threshold:
		{
			motor[dl]  = (vexRT[Ch3] );
		}
		else                                    // If the left joystick is within the threshold:
		{
			motor[dl]  = 0;                // Stop the left motor (cancel noise)
		}

		if(abs(vexRT[Ch2]) > threshold)         // If the right joystick is greater than or less than the threshold:
		{
			motor[dr] = (vexRT[Ch2]);
		}
		else                                    // If the right joystick is within the threshold:
		{
			motor[dr] = 0;                // Stop the right motor (cancel noise)
		}

		// SHOOTERS


		/*
		if( vexRT[ Btn6U ] == 1 )
		{
			if( ! shooterButtonPressed )
			{
				// change the toggle state
				shooterButtonToggleState = 1 - shooterButtonToggleState;

				// Note the button is pressed
				shooterButtonPressed = 1;
			}
		}
		else
		{
			// the button is not pressed
			shooterButtonPressed = 0;
		}

		if (shooterButtonToggleState) {
			motor[stl] = shooterSpeed;
			motor[sbl] = shooterSpeed;
			motor[str] = shooterSpeed;
			motor[sbr] = shooterSpeed;
			} else {
			motor[stl] = 0;
			motor[sbl] = 0;
			motor[str] = 0;
			motor[sbr] = 0;
		}

		*/


		//NON TOGGLE
		if (vexRT[Btn6U] == 1) {
		motor[stl] = shooterSpeed;
		motor[sbl] = shooterSpeed;
		motor[str] = shooterSpeed;
		motor[sbr] = shooterSpeed;
		} else {
		motor[stl] = 0;
		motor[sbl] = 0;
		motor[str] = 0;
		motor[sbr] = 0;
		}





		// Hold 5U to drive elevator

		if (vexRT[Btn5U] == 1) {
			motor[intakefront] = 127;
			motor[intakeback] = 127;
			} else {

			// If 5U isn't pressed
			// check for 5D which is
			// reverse. If neither, turn off.

			if (vexRT[Btn5D] == 1) {
				motor[intakefront] = -127;
				motor[intakeback] = -127;
				} else {
				motor[intakefront] = 0;
				motor[intakeback] = 0;
			}
		}
	}
}
