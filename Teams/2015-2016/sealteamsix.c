#pragma config(Motor,  port5,           intake1,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           intake3,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           dr,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           dl,            tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
  _____            _ _______                    _____ _
 / ____|          | |__   __|                  / ____(_)
| (___   ___  __ _| |  | | ___  __ _ _ __ ___ | (___  ___  __
 \___ \ / _ \/ _` | |  | |/ _ \/ _` | '_ ` _ \ \___ \| \ \/ /
 ____) |  __/ (_| | |  | |  __/ (_| | | | | | |____) | |>  <
|_____/ \___|\__,_|_|  |_|\___|\__,_|_| |_| |_|_____/|_/_/\_\

Weston Middle School
*/

#pragma platform(VEX)


//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!



// Required
void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................




}


task usercontrol()	{

	while (true) {

		int shooterSpeed = 127;

		// Used to filter out joystick abberations
		int threshold = 10;

		//////////////////////////////////////////////////////////
		//
		// DRIVE
		//
		// This code has filtering in place
		// Because the joystick returns a value that is not always
		// exactly zero.
		//
		// Because of this, the Cortex makes a whining sound
		// because the drive motors are being triggered
		// with values less than 10
		//
		// By testing if the joystick is within the threshold
		// We can turn off the motors and stop the noise
		// and power drain

		if(abs(vexRT[Ch3]) > threshold)         // If the left joystick is greater than or less than the threshold:
		{
			motor[dl]  = (vexRT[Ch3] );
		}
		else                                    // If the left joystick is within the threshold:
		{
			motor[dl]  = 0;                // Stop the left motor (cancel noise)
		}

		if(abs(vexRT[Ch2]) > threshold)         // If the right joystick is greater than or less than the threshold:
		{
			motor[dr] = (vexRT[Ch2]);
		}
		else                                    // If the right joystick is within the threshold:
		{
			motor[dr] = 0;                // Stop the right motor (cancel noise)
		}




		// Hold 5U to drive elevator

		if (vexRT[Btn6U] == 1) {
			motor[intake1] = 127;
			motor[intake2] = 127;
			motor[intake3] = 127;

			} else {

			// If 5U isn't pressed
			// check for 5D which is
			// reverse. If neither, turn off.

			if (vexRT[Btn6D] == 1) {
			motor[intake1] = -127;
			motor[intake2] = -127;
			motor[intake3] = -127;
				} else {
							motor[intake1] = 0;
							motor[intake2] = 0;
							motor[intake3] = 0;
			}
		}
	}
}
